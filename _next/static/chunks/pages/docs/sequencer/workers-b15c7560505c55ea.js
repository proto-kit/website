(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7297],{5305:function(e,s,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/sequencer/workers",function(){return t(5655)}])},5655:function(e,s,t){"use strict";t.r(s),t.d(s,{useTOC:function(){return useTOC}});var r=t(2676),i=t(4331),n=t(2423),a=t(9021);function useTOC(e){return[{value:"LocalTaskWorkerModule",id:"localtaskworkermodule",depth:2},{value:"WorkerReadyModule",id:"workerreadymodule",depth:2},{value:"SequencerStartUpModule",id:"sequencerstartupmodule",depth:2},{value:"Worker Start-up Flow",id:"worker-start-up-flow",depth:2},{value:"TaskQueue",id:"taskqueue",depth:2},{value:"BullQueue",id:"bullqueue",depth:3},{value:"LocalTaskQueue",id:"localtaskqueue",depth:3}]}s.default=(0,i.c)(function(e){let{toc:s=useTOC(e)}=e,t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{children:"Worker Architecture"}),"\n",(0,r.jsx)(t.p,{children:"The way protokit is architected, in regards to computation-heavy tasks, we have the following three-party setup:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Sequencer - this is the master “node” that does the sequencing, tracing and pushes proving tasks. In reality, this can be a multi-process deployment, but we can simplify this to a single actor here."}),"\n",(0,r.jsx)(t.li,{children:"Workers - One or more stateless actors that have a set of tasks that they can compute. Tasks in our case are mostly proving-related work."}),"\n",(0,r.jsx)(t.li,{children:"Message Queue - Distributes tasks from the sequencer to the workers and reports back the results"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["If ",(0,r.jsx)(t.code,{children:"worker"})," modules are defined in the AppChain it becomes a ",(0,r.jsx)(t.code,{children:"worker"}),". This has the same architecture as a regular AppChain,\nbut it can process expensive asynchronous ",(0,r.jsx)(t.code,{children:"tasks"}),", such as Block Proving. An AppChain can be defined such that only ",(0,r.jsx)(t.code,{children:"worker"})," modules are present, which means\nits only function is to execute tasks, rather than serve as a sequencer. For testing purposes, it is fine to have the main AppChain be the worker, but in\nproduction set-ups you will likely want multiple stand-alone workers defined, separately."]}),"\n",(0,r.jsx)(t.h2,{id:s[0].id,children:s[0].value}),"\n",(0,r.jsx)(t.p,{children:"This module is used to create a worker locally. Without this being defined in some process no worker will be spawned and\nthis means no tasks will be processed. This module is itself defined with several tasks that it will be capable of executing, such as"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"StateTransitionTask,"}),"\n",(0,r.jsx)(t.li,{children:"StateTransitionReductionTask,"}),"\n",(0,r.jsx)(t.li,{children:"RuntimeProvingTask,"}),"\n",(0,r.jsx)(t.li,{children:"BlockProvingTask,"}),"\n",(0,r.jsx)(t.li,{children:"BlockReductionTask,"}),"\n",(0,r.jsx)(t.li,{children:"BlockBuildingTask,"}),"\n",(0,r.jsx)(t.li,{children:"NewBlockTask,"}),"\n",(0,r.jsx)(t.li,{children:"CircuitCompilerTask"}),"\n",(0,r.jsx)(t.li,{children:"WorkerRegistrationTask."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["When the ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," is started it has a subset of start-up tasks, like those above, passed to it.\nThese tasks basically define what sort of computations the worker can handle, as you may want different workers to handle different tasks for resourcing reasons.\nFor example, the majority of the work the AppChain will do is for State Transition related tasks, and so you may want to configure a large share of the workers to handle only the StateTransitionTask\nand StateTransitionReductionTask, which allows easier scalability as only one circuit will be kept in memory. There are two types of tasks: ",(0,r.jsx)(t.code,{children:"Unprepared"}),", i.e. tasks that don’t have a prepare method and therefore don’t need to wait for registration to get initialized, and\n",(0,r.jsx)(t.code,{children:"Regular"}),", i.e. all other tasks that require registration."]}),"\n",(0,r.jsxs)(t.p,{children:["When the worker is started it first registers the required callback functions for the ",(0,r.jsx)(t.code,{children:"Unprepared"})," tasks, i.e. ",(0,r.jsx)(t.code,{children:"CircuitCompilerTask"})," and ",(0,r.jsx)(t.code,{children:"WorkerRegistrationTask"}),",\nwith its local instance of the queue. Then, the ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," calls the ",(0,r.jsx)(t.code,{children:"prepare"})," method for non-startup/normal tasks, before registering their callbacks with the queue.\nThis registration ensures the worker is ready to handle any request when one later arrives via the queue. Once all the tasks are registered a promise is resolved, called ",(0,r.jsx)(t.code,{children:"prepareResolve"}),".\nThis tells the ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," it is ready, and the ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," emits a ",(0,r.jsx)(t.code,{children:"ready"})," event of its own that other modules like the ",(0,r.jsx)(t.code,{children:"WorkerReadyModule"})," are waiting for to proceed."]}),"\n",(0,r.jsx)(t.h2,{id:s[1].id,children:s[1].value}),"\n",(0,r.jsxs)(t.p,{children:["This is another sequencer module that waits until key events have been emitted by the ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," to signal that the worker\nis ready and that the AppChain can continue. The ",(0,r.jsx)(t.code,{children:"WorkerReadyModule"})," is called by the ",(0,r.jsx)(t.code,{children:"AppChain.ts"})," at the end of the ",(0,r.jsx)(t.code,{children:"start()"})," method.\nIf the ",(0,r.jsx)(t.code,{children:"waitForReady()"})," method on the ",(0,r.jsx)(t.code,{children:"WorkerReadyModule"})," is never resolved then the AppChain will never finish its start-up. Note that the\n",(0,r.jsx)(t.code,{children:"waitForReady()"})," will always complete if the AppChain is not a worker, in particular if ",(0,r.jsx)(t.code,{children:"LocalTaskWorkerModule"})," is not defined."]}),"\n",(0,r.jsx)(t.h2,{id:s[2].id,children:s[2].value}),"\n",(0,r.jsxs)(t.p,{children:["This module is designed to ensure that all zk-circuits are compiled and their verification keys are accessible to the workers that\nwill need them. This spares workers from having to waste resources compiling the circuits themselves. This is achieved by having the AppChain\nuse the verification keys, which are static parameters, as input to the ",(0,r.jsx)(t.code,{children:"WorkerRegistrationFlow"}),". This in turns leaves\nit as a task on the queue. A worker when starting-up will process the task that has been pushed onto the queue and access these static parameters\nthat way. In order for subsequent workers to have access to the same task, which will be removed from the queue after having been executed, the\nsequencer uses the ",(0,r.jsx)(t.code,{children:"WorkerRegistrationFlow"})," to push the same task again in a boundless loop. This loop consumes no resources as it is just a ",(0,r.jsx)(t.code,{children:"Promise"})," that\nawaits until a worker has registered. We ensure it’s the new worker that picks up this task from the queue and not an older worker that is already configured,\nby having the old worker be configured to delete the task-handler for the registration from its local queue so that it can’t handle that particular kind of task, anymore."]}),"\n",(0,r.jsx)(t.h2,{id:s[3].id,children:s[3].value}),"\n",(0,r.jsx)(t.p,{children:"A summary of the worker registration flow. The sequencer is started and then:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["The worker registers the callbacks for ",(0,r.jsx)(t.code,{children:"Unprepared"})," tasks (i.e. those tasks that do not require the worker to be registered first) with the queue, one of which is the\n",(0,r.jsx)(t.code,{children:"WorkerRegistration"})," task and the other is ",(0,r.jsx)(t.code,{children:"CircuitCompilerTask"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["The AppChain, specifically ",(0,r.jsx)(t.code,{children:"SequencerStartupModule"}),", emits the ",(0,r.jsx)(t.code,{children:"CircuitCompilerTask"})," to compile certain zk-circuits of the various zk-Programs."]}),"\n",(0,r.jsxs)(t.li,{children:["The worker listens to the queue, processes the ",(0,r.jsx)(t.code,{children:"CircuitCompilerTask"})," task."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"SequencerStartupModule"})," invokes  the ",(0,r.jsx)(t.code,{children:"WorkerRegistrationFlow"}),", which submits a ",(0,r.jsx)(t.code,{children:"WorkerRegistration"})," task in a boundless\nloop to the queue. Within this task, the verification keys for the circuits are included."]}),"\n",(0,r.jsxs)(t.li,{children:["The worker listens to the queue, processes the ",(0,r.jsx)(t.code,{children:"WorkerRegistration"})," task and is initialised."]}),"\n",(0,r.jsxs)(t.li,{children:["The worker calls the ",(0,r.jsx)(t.code,{children:"prepare()"})," method for the ",(0,r.jsx)(t.code,{children:"Regular"})," tasks."]}),"\n",(0,r.jsxs)(t.li,{children:["The worker registers ",(0,r.jsx)(t.code,{children:"Regular"})," tasks with the queue."]}),"\n",(0,r.jsx)(t.li,{children:"The worker is now able to process all configured tasks emitted to the queue."}),"\n",(0,r.jsx)(t.li,{children:"The AppChain continues and starts submitting tasks, like BlockProving and StateTransition, say, to the queue."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:s[4].id,children:s[4].value}),"\n",(0,r.jsx)(t.p,{children:"The TaskQueue has two different implementations:"}),"\n",(0,r.jsx)(t.h3,{id:s[5].id,children:s[5].value}),"\n",(0,r.jsx)(t.p,{children:"This is Redis underneath. Each worker registers to consume specific jobs. Redis takes care of a lot of the implementation details.\nThis uses a separate Redis instance, whose configuration details are shared with the AppChain  on start-up.\nIn the starter-kit, this is run from Docker."}),"\n",(0,r.jsx)(t.h3,{id:s[6].id,children:s[6].value}),"\n",(0,r.jsxs)(t.p,{children:["This can only be used by one worker built into the AppChain, as it’s not really a queue, executing tasks directly where possible.\nThe ",(0,r.jsx)(t.code,{children:"workNextTasks()"})," is called whenever a task is added to the queue and again after tasks have already been executed (in case any others have been added in the meanwhile).\nThe ",(0,r.jsx)(t.code,{children:"LocalTaskQueue"})," isn’t suitable for production usage because it runs only one instance in-process. But for mock-proofs it’s good enough."]})]})},"/docs/sequencer/workers",{filePath:"src/pages/docs/sequencer/workers.mdx",timestamp:1763551153e3,pageMap:n.v,frontMatter:{},title:"Worker Architecture"},"undefined"==typeof RemoteContent?useTOC:RemoteContent.useTOC)}},function(e){e.O(0,[4331,2423,9774,2888,179],function(){return e(e.s=5305)}),_N_E=e.O()}]);