(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1706],{4052:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reference/protocol/README",function(){return n(7733)}])},7733:function(e,t,n){"use strict";n.r(t),n.d(t,{useTOC:function(){return useTOC}});var r=n(2676),o=n(4331),s=n(4080),a=n(9021);function useTOC(e){return[{value:"StateTransitionProver",id:"statetransitionprover",depth:3},{value:"BlockProver",id:"blockprover",depth:3},{value:"RollupMerkleTree",id:"rollupmerkletree",depth:3}]}t.default=(0,o.c)(function(e){let{toc:t=useTOC(e)}=e,n={a:"a",code:"code",h1:"h1",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"@proto-kit/protocol"})," • ",(0,r.jsx)(n.a,{href:"globals",children:(0,r.jsx)(n.strong,{children:"Docs"})})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"../../README",children:"Documentation"})," / @proto-kit/protocol"]}),"\n",(0,r.jsx)(n.h1,{children:"YAB: Protocol"}),"\n",(0,r.jsx)(n.p,{children:"Protocol contains to all circuit-aware data types and provers"}),"\n",(0,r.jsx)(n.h3,{id:t[0].id,children:t[0].value}),"\n",(0,r.jsx)(n.p,{children:"The StateTransitionProver takes a list of StateTransitions, checks and proves their precondition and update to the respective merkletree represented by the state root public input."}),"\n",(0,r.jsx)(n.p,{children:"In the public input, the prover transitions from two fields:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"state root"}),"\n",(0,r.jsx)(n.li,{children:"transitions hash"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The transitions hash is the commitment to a hash list where every state transition gets appended one-by-one."}),"\n",(0,r.jsx)(n.p,{children:"The StateTransitionsProver batches the application of multiple state transitions together.\nIf the amount of state transitions if greater than the batch size, the seperate proofs can be merged together."}),"\n",(0,r.jsx)(n.p,{children:"In the end, the publicInput of the StateTransitionProof should contain the following content:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fromTransitionsHash: 0"})," To prove that all STs have been applied, the transitionsHash must start at zero (i.e. a empty hash list)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toTransitionsHash"})," This value must be the same as the transitionsHash in the AppChainProof to guarantee that all (and same) statetransitions that have been outputted by the AppChain have been applied"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"from- and toStateRoot"})," These values represent the root of the state tree and will later be stitched together to arrive at the final stateroot for a bundle"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:t[1].id,children:t[1].value}),"\n",(0,r.jsx)(n.p,{children:"The BlockProver’s responsibility is to verify and put together the AppChainProof and StateTransitionProof.\nIt verifies that the transitionsHash is the same across both proofs and then takes the new state root proved by the STProof."}),"\n",(0,r.jsx)(n.p,{children:"In the end, the BlockProof proofs that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"the AppChain has been executed correctly"}),"\n",(0,r.jsx)(n.li,{children:"the resulting state changes have been applied correctly and fully to the state root"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Multiple BlockProofs will then be merged together, signed by the sequencer and published to the base layer."}),"\n",(0,r.jsx)(n.h3,{id:t[2].id,children:t[2].value}),"\n",(0,r.jsxs)(n.p,{children:["The RollupMerkleTree is a custom merkle tree implementation that supports the injection of a storage adapter.\nThe interface for that adapter can be found as the interface ",(0,r.jsx)(n.code,{children:"MerkleTreeStorage"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Adapters can implement any storage backend, like In-Memory and Database, and supports a process called “virtualization”.\nVirtualization is the process of layering different Adapters on top of each other.\nFor example if I want to simulate some transactions to a merkle tree, I can virtualize a database adapter into a MemoryAdapter.\nIf I am happy with the result, I can merge the results into the database or, if not, discard them without writing the changes to the database."})]})},"/docs/reference/protocol/README",{filePath:"src/pages/docs/reference/protocol/README.md",pageMap:s.v,frontMatter:{title:"@proto-kit/protocol"},title:"@proto-kit/protocol"},"undefined"==typeof RemoteContent?useTOC:RemoteContent.useTOC)}},function(e){e.O(0,[4331,4080,9774,2888,179],function(){return e(e.s=4052)}),_N_E=e.O()}]);