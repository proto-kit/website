(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1570],{895:function(e,t,o){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/architecture/protocol",function(){return o(4711)}])},4711:function(e,t,o){"use strict";o.r(t),o.d(t,{useTOC:function(){return useTOC}});var n=o(2676),i=o(4331),r=o(2423),s=o(9021);function useTOC(e){return[{value:"State transitions",id:"state-transitions",depth:2},{value:"Block production",id:"block-production",depth:2},{value:"Extending the protocol with hooks",id:"extending-the-protocol-with-hooks",depth:2}]}t.default=(0,i.c)(function(e){let{toc:t=useTOC(e)}=e,o={blockquote:"blockquote",em:"em",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h1,{children:"Protocol"}),"\n",(0,n.jsx)(o.p,{children:"Protocol is the centerpiece of every Protokit app-chain. Firstly it defines how state transitions generated by the rest of the framework are\napplied to the underlying state tree. Secondly it determines how proofs of state transitions are brought together with proofs of runtime execution\nto form a block, or at least a part of it."}),"\n",(0,n.jsxs)(o.p,{children:["Every protocol is composed of ",(0,n.jsx)(o.em,{children:"protocol modules"}),", following the modular design of Protokit. The bare minimum protocol must\nalways contain a ",(0,n.jsx)(o.em,{children:"StateTransitionProver"})," and a ",(0,n.jsx)(o.em,{children:"BlockProver"})," module."]}),"\n",(0,n.jsx)(o.p,{children:"Although modular, the protocol and sequencer have a certain level of coupling, therefore the need to always specify the state transition and block prover modules.\nThe underlying coupling of the protocol and the sequencer comes from the orchestrational (block production) responsibilities of the sequencer."}),"\n",(0,n.jsx)(o.h2,{id:t[0].id,children:t[0].value}),"\n",(0,n.jsxs)(o.p,{children:["One of the core responsibilities of the protocol, is to define how state transitions coming from the rest of the framework are applied to the underlying\nstate tree. State transition is defined by ",(0,n.jsx)(o.em,{children:"path"}),", ",(0,n.jsx)(o.em,{children:"from"})," and ",(0,n.jsx)(o.em,{children:"to"})," properties, where from/to are optional values."]}),"\n",(0,n.jsxs)(o.p,{children:["This enables state transitions not only to model how a state moves forward, but also to define how a state is meant to look like at a certain point in time.\nThe ability to reason about the current state is reffered to as ",(0,n.jsx)(o.strong,{children:"preconditions"}),". The state transition prover implementation shipped with Protokit, is capable of\nboth enforcing state transition preconditions and state writes."]}),"\n",(0,n.jsx)(o.p,{children:"Most importantly, state transition preconditions allow the sequencer to supply unchecked values during on-chain execution of runtime, and still be able to prove the correctness\nof the values supplied within the protocol."}),"\n",(0,n.jsx)(o.p,{children:"Circuits for applying state transitions to the state tree are inifinitely recursive, in order to compensate for the current O1JS circuit size limits. This allows us to apply arbitrary\namount of state transitions per e.g. each runtime method execution."}),"\n",(0,n.jsx)(o.h2,{id:t[1].id,children:t[1].value}),"\n",(0,n.jsx)(o.p,{children:"Blocks are created by either merging a runtime execution proof with a state transition proof, or by merging two block proofs.\nApplying a transaction to a block requires two things: a runtime proof and a state transition proof. Both of these proofs are merged together to generate a ‘block proof’ within the block prover.\nAs part of this process, both proofs’s commitments are cross checked to have proven their computation on top of the same underlying data. This means for instance checking\nif the state transition proof applied all the state transitions emitted by the runtime proof."}),"\n",(0,n.jsx)(o.h2,{id:t[2].id,children:t[2].value}),"\n",(0,n.jsxs)(o.p,{children:["Protocol modules can extend tap into the lifecycle of the existing protocol, by specifying protocol hooks.\nMultiple different protocol hook injection points are available in the protocol out of the box: ",(0,n.jsx)(o.em,{children:"onTransaction"}),", ",(0,n.jsx)(o.em,{children:"beforeBlock"})," and ",(0,n.jsx)(o.em,{children:"afterBlock"}),"."]}),"\n",(0,n.jsxs)(o.p,{children:["The ",(0,n.jsx)(o.em,{children:"onTransaction"})," hooks have access to the state tree, and can emit state transitions as well. For instance account nonce tracking\nis implemented as an onTransaction hook.\nHooks are executed from within the block prover, and have access to additional protocol context as well. (e.g. which transaction invoked the hook)"]}),"\n",(0,n.jsxs)(o.blockquote,{children:["\n",(0,n.jsx)(o.p,{children:"Protocol hooks also allow us to keep track of the last known network state, allowing for an implementation of historical state proofs."}),"\n"]})]})},"/docs/architecture/protocol",{filePath:"src/pages/docs/architecture/protocol.mdx",timestamp:1763551153e3,pageMap:r.v,frontMatter:{},title:"Protocol"},"undefined"==typeof RemoteContent?useTOC:RemoteContent.useTOC)}},function(e){e.O(0,[4331,2423,9774,2888,179],function(){return e(e.s=895)}),_N_E=e.O()}]);